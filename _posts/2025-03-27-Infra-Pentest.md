---
layout: post
title: Comment j'ai montÃ© mon lab pentest chez moi
---

![]({{ site.baseurl }}/images/home-server.png){:class="img-responsive"}


## Besoin 

Dans le cadre de mes divers labs, formation ou autre expÃ©rimentation de cybersÃ©curitÃ© j'avais pour habitude de lancer des machines virtuelles sur mon poste en local. Seulement cette approche pose plusieurs problÃ¨mes. DÃ©jÃ  en tant que propriÃ©taire de Mac M2 je ne pouvais pas faire fonctionner de maniÃ¨re fiable des machines virtuels a base de processeur X86. Enfin, jongler entre mon poste fixe et mn laptop rendais difficile de dÃ©buter un travail sur une machine (typiquement mon laptop) et de le finir ensuite sur une autre (mon poste fixe). 

## IdÃ©e 

J'ai d'abord pensÃ© a souscrire a un abonnement OVH ou autre pour un Bare Metal me permettant de dÃ©ployer un Proxmox ou tout autre solution de virtualisation pour y dÃ©ployer des machines en fonction des besoins. Mais je souhaitais avoir une machine installÃ©e chez moi, pouvoir exploiter mon serveur NAS et n'avais pas forcÃ©ment besoin d'un Proxmox et de toutes ses fonctionnalitÃ©s. 

J'ai donc tournÃ© mon attention vers une machine de type Intel Nuc afin d'hÃ©berger une machine faible consommation chez moi avec des capacitÃ©s de virtualisation et des performances suffisante pour y parvenir. Dans mon cas je souhaitais un budget maintenus avec les spÃ©cifications minimum suivantes : 

- 32 Go de RAM
- 8 coeurs CPU 
- 1 To de stockage local

> De plus cette approche me permets de dÃ©porter mon lab et m'Ã©vite au maximum de perdre mon travail en cas de vol de mon laptop tout en me permettant d'exploiter mes vieux Thinkpads au besoin pour travailler sur mes labs.

Il me suffirait ensuite de mettre en place une solution VPN comme Wireguard ou Tailscale. 

## Solution 

Pour mon serveur je suis donc partis sur la configuration suivante :

- Un Minisforum UM690 Slim
- 2 To de stockage Nvme 
- Une barette de 48 Go de RAM

L'UM690 Slim offre un CPU Ryzen 9 6900HX avec 6 coeurs et 16 Threads ce qui rÃ©ponds au besoin. Pour ce qui est de la RAM j'ai privilÃ©giÃ© la capacitÃ© de mise a jour du matÃ©riel aux performances pure ce qui explique le choix d'une seule barrette. Le CPU Ã©tant capable de gÃ©rer jusqu'a 96 Go de RAM il m'est passible de rajouter une barrette plus tard si j'ai besoin de plus de mÃ©moire vive. Ce qui serait plus pratique que de devoir remplacer deux barrettes. 

Pour ce qui est de l'accÃ¨s distant je vais partir sur Tailscale. En effet, bien que la solution soit moins indÃ©pendante que Wireguard, elle me permets de modifier a la volÃ©e la configuration du VPN et d'ajouter/supprimer facilement des agents. C'est surtout pratique dans mon cas pour me permettre d'ajouter ou supprimer des machines en fonction de mes besoins et surtout pour Ãªtre capable de supprimer une machine cliente en cas de vol. 

Enfin cette solution permets de se passer de solutions comme DynDNS pour permettre l'accÃ¨s distant quand les IP fixes ne sont pas disponibles chez votre FAI.

Pour ce qui est de la sÃ©curisation de l'accÃ¨s je vais dÃ©ployer une machine Bastion SSH qui seras le seule point d'entrÃ©e vers les machines virtuelles. Dans le cas du SSH, le Bastion serviras de jump host et tous les autres protocoles passerons par des tunnels SSH (le RDP par exemple). Ce Bastion porteras son propre agent Tailscale afin d'Ãªtre joignable en direct tout en plaÃ§ant des ACL. 
Le serveur en lui-mÃªme seras Ã©galement Ã©quipÃ© d'un agent Tailscale afin d'exposer un interface web de gestion des VM, lui aussi avec des ACL. 

Pour ce qui est de la virtualisation, je souhaitais utiliser KVM car c'est un hyperviseur que je maitrise bien. NÃ©anmoins suite a l'arrÃªt de la maintenance de Virt-Manager, je ne disposait plus de solution pratique et efficace pour gÃ©rer mes VM. Fort heureusement une solution de remplacement du nom de Cockpit existe et est suffisamment mature pour mon besoin. 

Nous avons donc le Hardware, la solution de virtualisation, les solutions d'accÃ¨s a distance et enfin une solution de sÃ©curisation.

Voici le schÃ©ma de principe de tout ce que l'on s'est dis : 

```mermaid
graph TD;
  
  %% Internet et accÃ¨s externe
  subgraph WAN
    Internet["ðŸŒ Internet"]
  end

  subgraph TAILSCALE_NET["VPN Tailscale"]
    DEB_BASTION["ðŸ”’ DEB-BASTION (99.98.66.2)"]
    VM_SRV["ðŸ–¥ï¸ VM-SRV (99.98.66.1)"]
  end

  subgraph LOCAL_NET["RÃ©seau Local"]
    VM_SRV_LOCAL["ðŸ–¥ï¸ VM-SRV (192.168.1.xx)"]
  end

  subgraph VIRTUAL_NET["KVM (192.168.122.0/24)"]
    KAL_PENTEST["ðŸ‰ KAL-PENTEST (192.168.122.xx)"]
    WIN_COMPIL["ðŸ–¥ï¸ WIN-COMPIL (192.168.122.xx)"]
  end

  %% Flux rÃ©seau physique
  Internet -..->|"ðŸš« Pas d'accÃ¨s direct"| DEB_BASTION
  Internet -..->|"ðŸš« Pas d'accÃ¨s direct"| VM_SRV

  DEB_BASTION -->|Tailscale VPN| VM_SRV
  VM_SRV -- eno1 --> VM_SRV_LOCAL
  VM_SRV -- virbr0 --> KAL_PENTEST
  VM_SRV -- virbr0 --> WIN_COMPIL
  
  %% Flux logiques (SSH, tunnels)
  DEB_BASTION ==>|"Jump Host"| KAL_PENTEST
  DEB_BASTION ==>|"Jump Host"| WIN_COMPIL
  DEB_BASTION ==>|"Tunnel SSH 3389 (RDP)"| WIN_COMPIL

  %% LÃ©gendes des flux
 subgraph EXPLICATIONS ["ðŸ’¡ Explications"]
    Note1["ðŸ”¹ DEB-BASTION est accessible uniquement via Tailscale"]
    Note2["ðŸ”¹ VM-SRV hÃ©berge les VM et expose le port 9090"]
    Note3["ðŸ”¹ WIN-COMPIL est accessible en RDP via tunnel SSH"]
  end

  Note1 --> DEB_BASTION
  Note2 --> VM_SRV
  Note3 --> WIN_COMPIL


```

> Les IP sont volontairement bidons

### Le Bastion 

Le serveur de bastion est configurÃ© pour refuser toutes les connexions avec session interactives et ne permets que de rÃ©aliser du tunneling ou du Jump Host. Pour cela j'ai dÃ©ployÃ© une configuration qui ressemble a ceci : 

```bash
sudo usermod --shell /usr/sbin/nologin bastion

## /etc/ssh/sshd_config
# DÃ©sactiver l'authentification par mot de passe
PasswordAuthentication no
ChallengeResponseAuthentication no

# DÃ©sactiver l'accÃ¨s interactif au compte "bastion"
Match User bastion
    PermitTTY no
    ForceCommand echo "AccÃ¨s interdit en mode interactif"
```

Pour accÃ©der aux machines virtuels, je vais exploiter deux paires de clÃ© SSH. Une permettant de se connecter du client vers le Bastion et une permettant de se connecter du Bastion a la VM cible : 

```mermaid
graph TD;

  %% DÃ©finition des machines
  subgraph CLIENT["ðŸ’» Client"]
    Client["ðŸ‘¤ Utilisateur"]
  end

  subgraph BASTION["ðŸ›¡ï¸ Bastion"]
    Bastion["ðŸ”’ Serveur Bastion"]
  end

  subgraph CIBLE["ðŸŽ¯ Machine Cible"]
    Cible["ðŸ–¥ï¸ Serveur Cible"]
  end

  %% Connexions SSH
  Client -.->|"ðŸ”‘ ClÃ© SSH 1 et 2"| Bastion
  Bastion -.->|"ðŸ”‘ ClÃ© SSH 2"| Cible
```

J'aurais aimÃ© faire en sorte que le Bastion porte sa propre clÃ© SSH afin d'Ã©viter de devoir me trimballer deux clÃ©s mais je ne suis pas parvenus a faire autrement. 

### Les ACL 

Sur Tailscale, j'ai mis en place des ACL afin de sÃ©curiser les accÃ¨s aux diverses interfaces/services. Je souhaite uniquement joindre le serveur hyperviseur via son interface web et n'autoriser que le port SSH vers le Bastion. Voici donc la configuration choisie : 


```mermaid
graph TD;

  %% DÃ©finition des machines et tags
  subgraph SERVERS["ðŸ–¥ï¸ Serveurs"]
    VM_SRV["ðŸ–¥ï¸ VM-SRV\n(tag:server)"]
    DEB_BASTION["ðŸ”’ DEB-BASTION\n(tag:admin)"]
  end

  %% DÃ©finition des ACLs
  subgraph RULES["ðŸ“œ ACLs"]
    ACL1["âœ… Autorise * â†’ tag:server:9090"]
    ACL2["âœ… Autorise * â†’ tag:admin:22"]
  end

  %% Liaisons des ACLs aux machines concernÃ©es
  ACL1 -->|Port Cockpit Web| VM_SRV
  ACL2 -->|Port SSH| DEB_BASTION


```

Ce qui donne en cas concret : 

```bash
{
	"tagOwners": {
		"tag:server": ["autogroup:admin"], // VM-SRV
		"tag:admin":  ["autogroup:admin"], // DEB-BASTION
	},

	"acls": [
		// ðŸ”¹ Autoriser SSH (22) et Cockpit Web (9090) pour les serveurs
		{
			"action": "accept",
			"src":    ["*"],
			"dst":    ["tag:server:9090"],
		},

		// ðŸ”¹ Autoriser SSH (22) pour DEB-BASTION
		{
			"action": "accept",
			"src":    ["*"],
			"dst":    ["tag:admin:22"],
		},
	],
}

```

Enfin, j'ai mis en place une rÃ©gle iptables pour bloquer completement toutes tentative de connexion a mon rÃ©seau local depuis une VM. Cela permets d'Ã©viter toutes fuites involontaire vers mon rÃ©seau local : 

Blocage des IP locales via les VM : 

```bash
sudo iptables -I FORWARD -i virbr0 -d 192.168.1.0/24 -j DROP
```

Enfin, pour simplifier mon utilisation quotidienne aux machines, j'ai mis en place une configuration SSH : 

```bash
# Login Bastion 
Host deb-bastion
  Hostname 99.98.66.2
  User bastion
  ForwardAgent yes
# Login kali en SSH
Host kal-pentest
  Hostname 192.168.122.xx
  User jugu
  ForwardAgent yes
  IdentityFile ~/.ssh/id_rsa_bastion
  ProxyJump deb-bastion
# Monter les tunnel SSH pour exposer le 3389 des machines
Host VM_ALL
  HostName deb-bastion
  User bastion
  LocalForward 3389 192.168.122.xx:3389
  LocalForward 3390 192.168.122.xx:3389
  RequestTTY no
```

J'ai une configuration pour permettre la connexion au bastion, elle serviras ensuite pour le jump host vers la machine Kali Linux de l'exemple. Pour finir, une derniÃ¨re configuration permets de crÃ©er des tunnel SSH pour ouvrir des connexions RDP vers les VM. 

Il suffit alors de rajouter des machines au besoin en se basant sur la mÃªme configuration. 

