---
layout: post
title: Comment j'ai mont√© mon lab pentest chez moi
tags: [Mermaid]
mermaid: true
---

![]({{ site.baseurl }}/images/home-server.png){:class="img-responsive"}


## Besoin 

Dans le cadre de mes divers labs, formation ou autre exp√©rimentation de cybers√©curit√© j'avais pour habitude de lancer des machines virtuelles sur mon poste en local. Seulement cette approche pose plusieurs probl√®mes. D√©j√† en tant que propri√©taire de Mac M2 je ne pouvais pas faire fonctionner de mani√®re fiable des machines virtuels a base de processeur X86. Enfin, jongler entre mon poste fixe et mn laptop rendais difficile de d√©buter un travail sur une machine (typiquement mon laptop) et de le finir ensuite sur une autre (mon poste fixe). 

## Id√©e 

J'ai d'abord pens√© a souscrire a un abonnement OVH ou autre pour un Bare Metal me permettant de d√©ployer un Proxmox ou tout autre solution de virtualisation pour y d√©ployer des machines en fonction des besoins. Mais je souhaitais avoir une machine install√©e chez moi, pouvoir exploiter mon serveur NAS et n'avais pas forc√©ment besoin d'un Proxmox et de toutes ses fonctionnalit√©s. 

J'ai donc tourn√© mon attention vers une machine de type Intel Nuc afin d'h√©berger une machine faible consommation chez moi avec des capacit√©s de virtualisation et des performances suffisante pour y parvenir. Dans mon cas je souhaitais un budget maintenus avec les sp√©cifications minimum suivantes : 

- 32 Go de RAM
- 8 coeurs CPU 
- 1 To de stockage local

> De plus cette approche me permets de d√©porter mon lab et m'√©vite au maximum de perdre mon travail en cas de vol de mon laptop tout en me permettant d'exploiter mes vieux Thinkpads au besoin pour travailler sur mes labs.

Il me suffirait ensuite de mettre en place une solution VPN comme Wireguard ou Tailscale. 

## Solution 

Pour mon serveur je suis donc partis sur la configuration suivante :

- Un Minisforum UM690 Slim
- 2 To de stockage Nvme 
- Une barette de 48 Go de RAM

L'UM690 Slim offre un CPU Ryzen 9 6900HX avec 6 coeurs et 16 Threads ce qui r√©ponds au besoin. Pour ce qui est de la RAM j'ai privil√©gi√© la capacit√© de mise a jour du mat√©riel aux performances pure ce qui explique le choix d'une seule barrette. Le CPU √©tant capable de g√©rer jusqu'a 96 Go de RAM il m'est passible de rajouter une barrette plus tard si j'ai besoin de plus de m√©moire vive. Ce qui serait plus pratique que de devoir remplacer deux barrettes. 

Pour ce qui est de l'acc√®s distant je vais partir sur Tailscale. En effet, bien que la solution soit moins ind√©pendante que Wireguard, elle me permets de modifier a la vol√©e la configuration du VPN et d'ajouter/supprimer facilement des agents. C'est surtout pratique dans mon cas pour me permettre d'ajouter ou supprimer des machines en fonction de mes besoins et surtout pour √™tre capable de supprimer une machine cliente en cas de vol. 

Enfin cette solution permets de se passer de solutions comme DynDNS pour permettre l'acc√®s distant quand les IP fixes ne sont pas disponibles chez votre FAI.

Pour ce qui est de la s√©curisation de l'acc√®s je vais d√©ployer une machine Bastion SSH qui seras le seule point d'entr√©e vers les machines virtuelles. Dans le cas du SSH, le Bastion serviras de jump host et tous les autres protocoles passerons par des tunnels SSH (le RDP par exemple). Ce Bastion porteras son propre agent Tailscale afin d'√™tre joignable en direct tout en pla√ßant des ACL. 
Le serveur en lui-m√™me seras √©galement √©quip√© d'un agent Tailscale afin d'exposer un interface web de gestion des VM, lui aussi avec des ACL. 

Pour ce qui est de la virtualisation, je souhaitais utiliser KVM car c'est un hyperviseur que je maitrise bien. N√©anmoins suite a l'arr√™t de la maintenance de Virt-Manager, je ne disposait plus de solution pratique et efficace pour g√©rer mes VM. Fort heureusement une solution de remplacement du nom de Cockpit existe et est suffisamment mature pour mon besoin. 

Nous avons donc le Hardware, la solution de virtualisation, les solutions d'acc√®s a distance et enfin une solution de s√©curisation.

Voici le sch√©ma de principe de tout ce que l'on s'est dis : 

<div class="mermaid">
graph TD;
  
  %% Internet et acc√®s externe
  subgraph WAN
    Internet["üåç Internet"]
  end

  subgraph TAILSCALE_NET["VPN Tailscale"]
    DEB_BASTION["üîí DEB-BASTION (99.98.66.2)"]
    VM_SRV["üñ•Ô∏è VM-SRV (99.98.66.1)"]
  end

  subgraph LOCAL_NET["R√©seau Local"]
    VM_SRV_LOCAL["üñ•Ô∏è VM-SRV (192.168.1.xx)"]
  end

  subgraph VIRTUAL_NET["KVM (192.168.122.0/24)"]
    KAL_PENTEST["üêâ KAL-PENTEST (192.168.122.xx)"]
    WIN_COMPIL["üñ•Ô∏è WIN-COMPIL (192.168.122.xx)"]
  end

  %% Flux r√©seau physique
  Internet -..->|"üö´ Pas d'acc√®s direct"| DEB_BASTION
  Internet -..->|"üö´ Pas d'acc√®s direct"| VM_SRV

  DEB_BASTION -->|Tailscale VPN| VM_SRV
  VM_SRV -- eno1 --> VM_SRV_LOCAL
  VM_SRV -- virbr0 --> KAL_PENTEST
  VM_SRV -- virbr0 --> WIN_COMPIL
  
  %% Flux logiques (SSH, tunnels)
  DEB_BASTION ==>|"Jump Host"| KAL_PENTEST
  DEB_BASTION ==>|"Jump Host"| WIN_COMPIL
  DEB_BASTION ==>|"Tunnel SSH 3389 (RDP)"| WIN_COMPIL

  %% L√©gendes des flux
 subgraph EXPLICATIONS ["üí° Explications"]
    Note1["üîπ DEB-BASTION est accessible uniquement via Tailscale"]
    Note2["üîπ VM-SRV h√©berge les VM et expose le port 9090"]
    Note3["üîπ WIN-COMPIL est accessible en RDP via tunnel SSH"]
  end

  Note1 --> DEB_BASTION
  Note2 --> VM_SRV
  Note3 --> WIN_COMPIL
</div>

> Les IP sont volontairement bidons

### Le Bastion 

Le serveur de bastion est configur√© pour refuser toutes les connexions avec session interactives et ne permets que de r√©aliser du tunneling ou du Jump Host. Pour cela j'ai d√©ploy√© une configuration qui ressemble a ceci : 

```bash
sudo usermod --shell /usr/sbin/nologin bastion

## /etc/ssh/sshd_config
# D√©sactiver l'authentification par mot de passe
PasswordAuthentication no
ChallengeResponseAuthentication no

# D√©sactiver l'acc√®s interactif au compte "bastion"
Match User bastion
    PermitTTY no
    ForceCommand echo "Acc√®s interdit en mode interactif"
```

Pour acc√©der aux machines virtuels, je vais exploiter deux paires de cl√© SSH. Une permettant de se connecter du client vers le Bastion et une permettant de se connecter du Bastion a la VM cible : 

<div class="mermaid">
graph TD;

  %% D√©finition des machines
  subgraph CLIENT["üíª Client"]
    Client["üë§ Utilisateur"]
  end

  subgraph BASTION["üõ°Ô∏è Bastion"]
    Bastion["üîí Serveur Bastion"]
  end

  subgraph CIBLE["üéØ Machine Cible"]
    Cible["üñ•Ô∏è Serveur Cible"]
  end

  %% Connexions SSH
  Client -.->|"üîë Cl√© SSH 1 et 2"| Bastion
  Bastion -.->|"üîë Cl√© SSH 2"| Cible
</div>

J'aurais aim√© faire en sorte que le Bastion porte sa propre cl√© SSH afin d'√©viter de devoir me trimballer deux cl√©s mais je ne suis pas parvenus a faire autrement. 

### Les ACL 

Sur Tailscale, j'ai mis en place des ACL afin de s√©curiser les acc√®s aux diverses interfaces/services. Je souhaite uniquement joindre le serveur hyperviseur via son interface web et n'autoriser que le port SSH vers le Bastion. Voici donc la configuration choisie : 


<div class="mermaid">
graph TD;

  %% D√©finition des machines et tags
  subgraph SERVERS["üñ•Ô∏è Serveurs"]
    VM_SRV["üñ•Ô∏è VM-SRV\n(tag:server)"]
    DEB_BASTION["üîí DEB-BASTION\n(tag:admin)"]
  end

  %% D√©finition des ACLs
  subgraph RULES["üìú ACLs"]
    ACL1["‚úÖ Autorise * ‚Üí tag:server:9090"]
    ACL2["‚úÖ Autorise * ‚Üí tag:admin:22"]
  end

  %% Liaisons des ACLs aux machines concern√©es
  ACL1 -->|Port Cockpit Web| VM_SRV
  ACL2 -->|Port SSH| DEB_BASTION

</div>

Ce qui donne en cas concret : 

```bash
{
	"tagOwners": {
		"tag:server": ["autogroup:admin"], // VM-SRV
		"tag:admin":  ["autogroup:admin"], // DEB-BASTION
	},

	"acls": [
		// üîπ Autoriser SSH (22) et Cockpit Web (9090) pour les serveurs
		{
			"action": "accept",
			"src":    ["*"],
			"dst":    ["tag:server:9090"],
		},

		// üîπ Autoriser SSH (22) pour DEB-BASTION
		{
			"action": "accept",
			"src":    ["*"],
			"dst":    ["tag:admin:22"],
		},
	],
}

```

Enfin, j'ai mis en place une r√©gle iptables pour bloquer completement toutes tentative de connexion a mon r√©seau local depuis une VM. Cela permets d'√©viter toutes fuites involontaire vers mon r√©seau local : 

Blocage des IP locales via les VM : 

```bash
sudo iptables -I FORWARD -i virbr0 -d 192.168.1.0/24 -j DROP
```

Enfin, pour simplifier mon utilisation quotidienne aux machines, j'ai mis en place une configuration SSH : 

```bash
# Login Bastion 
Host deb-bastion
  Hostname 99.98.66.2
  User bastion
  ForwardAgent yes
# Login kali en SSH
Host kal-pentest
  Hostname 192.168.122.xx
  User jugu
  ForwardAgent yes
  IdentityFile ~/.ssh/id_rsa_bastion
  ProxyJump deb-bastion
# Monter les tunnel SSH pour exposer le 3389 des machines
Host VM_ALL
  HostName deb-bastion
  User bastion
  LocalForward 3389 192.168.122.xx:3389
  LocalForward 3390 192.168.122.xx:3389
  RequestTTY no
```

J'ai une configuration pour permettre la connexion au bastion, elle serviras ensuite pour le jump host vers la machine Kali Linux de l'exemple. Pour finir, une derni√®re configuration permets de cr√©er des tunnel SSH pour ouvrir des connexions RDP vers les VM. 

Il suffit alors de rajouter des machines au besoin en se basant sur la m√™me configuration. 

